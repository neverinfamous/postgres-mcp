#!/usr/bin/env python3
"""
SQL Injection Vulnerability Demonstration - Postgres MCP Server
===============================================================

This script demonstrates the SQL injection vulnerability in the Postgres MCP server's
execute_sql function, which is identical to the vulnerability found in the original
Anthropic SQLite MCP server.

VULNERABILITY LOCATION: src/postgres_mcp/server.py, line 396
    rows = await sql_driver.execute_query(sql)  # Direct injection point

This script shows:
1. How the vulnerability can be exploited
2. The difference between unrestricted and restricted modes
3. A simple fix using parameter binding

Author: Enhanced by neverinfamous
Date: September 28, 2025
"""

import asyncio
import os
import sys

# Fix Windows event loop compatibility with psycopg3
if sys.platform == "win32":
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

# Add the src directory to the path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "src"))

from postgres_mcp.sql import DbConnPool
from postgres_mcp.sql import SafeSqlDriver
from postgres_mcp.sql import SqlDriver


class VulnerabilityDemo:
    """Demonstrates the SQL injection vulnerability"""

    def __init__(self, connection_url: str):
        self.connection_url = connection_url
        self.db_pool = DbConnPool(connection_url)

    async def setup_demo_environment(self):
        """Set up a simple demo environment"""
        print("Setting up demo environment...")

        await self.db_pool.pool_connect()
        sql_driver = SqlDriver(conn=self.db_pool)

        # Create a simple users table
        await sql_driver.execute_query("""
            DROP TABLE IF EXISTS demo_users CASCADE;
            CREATE TABLE demo_users (
                id SERIAL PRIMARY KEY,
                username VARCHAR(50),
                email VARCHAR(100),
                is_admin BOOLEAN DEFAULT FALSE
            );
        """)

        # Insert sample data
        await sql_driver.execute_query("""
            INSERT INTO demo_users (username, email, is_admin) VALUES
            ('alice', 'alice@example.com', FALSE),
            ('bob', 'bob@example.com', FALSE),
            ('admin', 'admin@example.com', TRUE);
        """)

        print("Demo environment ready!")

    async def demonstrate_vulnerable_function(self):
        """Show how the current execute_sql function is vulnerable"""

        print("\n" + "=" * 60)
        print("VULNERABILITY DEMONSTRATION")
        print("=" * 60)

        sql_driver = SqlDriver(conn=self.db_pool)

        print("\n1. Normal usage (what users expect):")
        print("   Input: 1")

        # Simulate the vulnerable execute_sql function
        user_input = "1"
        vulnerable_query = f"SELECT * FROM demo_users WHERE id = '{user_input}'"
        print(f"   Generated SQL: {vulnerable_query}")

        result = await sql_driver.execute_query(vulnerable_query)
        if result:
            print(f"   Result: Found {len(result)} user(s)")
            for row in result:
                print(f"           {dict(row.cells)}")

        print("\n2. SQL Injection Attack (malicious input):")
        malicious_input = "1' UNION SELECT 999, 'hacker', 'hacker@evil.com', TRUE--"
        print(f"   Input: {malicious_input}")

        # This is exactly what happens in the current execute_sql function!
        # The payload includes the quote to close the string and -- to comment out the rest
        vulnerable_query = f"SELECT * FROM demo_users WHERE id = '{malicious_input}'"
        print(f"   Generated SQL: {vulnerable_query}")

        try:
            result = await sql_driver.execute_query(vulnerable_query)
            if result:
                print(f"   INJECTION SUCCESSFUL! Found {len(result)} rows:")
                for row in result:
                    row_data = dict(row.cells)
                    if row_data.get("username") == "hacker":
                        print(f"           MALICIOUS ROW: {row_data}")
                    else:
                        print(f"           {row_data}")
        except Exception as e:
            print(f"   Error: {e}")

    async def demonstrate_restricted_mode_protection(self):
        """Show how restricted mode protects against injection"""

        print("\n" + "=" * 60)
        print("RESTRICTED MODE PROTECTION")
        print("=" * 60)

        # Use SafeSqlDriver (restricted mode)
        safe_driver = SafeSqlDriver(SqlDriver(conn=self.db_pool), timeout=30)

        print("\nTesting the same malicious input in RESTRICTED mode:")
        malicious_input = "1' UNION SELECT 999, 'hacker', 'hacker@evil.com', TRUE--"
        vulnerable_query = f"SELECT * FROM demo_users WHERE id = '{malicious_input}'"
        print(f"   SQL: {vulnerable_query}")

        try:
            await safe_driver.execute_query(vulnerable_query)
            print("   Injection succeeded (this shouldn't happen!)")
        except Exception as e:
            print(f"   BLOCKED: {str(e)[:100]}...")
            print("   SafeSqlDriver successfully prevented the injection!")

    async def demonstrate_proper_fix(self):
        """Show how to properly fix the vulnerability with parameter binding"""

        print("\n" + "=" * 60)
        print("PROPER FIX - PARAMETER BINDING")
        print("=" * 60)

        sql_driver = SqlDriver(conn=self.db_pool)

        print("\nUsing parameterized queries (the correct approach):")

        # Proper parameter binding
        user_input = "1"
        safe_query = "SELECT * FROM demo_users WHERE id = %s"
        print(f"   Query template: {safe_query}")
        print(f"   Parameter: {user_input}")

        # This is how it should be done
        result = await sql_driver.execute_query(safe_query, params=[user_input])
        if result:
            print(f"   Normal result: {len(result)} user(s)")

        print("\nTesting malicious input with parameter binding:")
        malicious_input = "1 UNION SELECT 999, 'hacker', 'hacker@evil.com', TRUE"
        print(f"   Parameter: {malicious_input}")

        # Even with malicious input, parameter binding treats it as literal data
        try:
            result = await sql_driver.execute_query(safe_query, params=[malicious_input])
            print(f"   Safe result: {len(result) if result else 0} user(s) (injection treated as literal)")
        except Exception as e:
            if "invalid input syntax for type integer" in str(e):
                print("   PARAMETER BINDING SUCCESS!")
                print("   PostgreSQL correctly rejected the malicious input as invalid integer data")
                print("   This proves parameter binding prevents SQL injection attacks")
                print(f"   Technical details: {str(e)[:100]}...")
            else:
                print(f"   Unexpected error: {e}")
                raise

        print("\nThe fix is simple:")
        print("   OLD: sql_driver.execute_query(f'SELECT * FROM table WHERE id = {user_input}')")
        print("   NEW: sql_driver.execute_query('SELECT * FROM table WHERE id = %s', params=[user_input])")

    def show_code_fix(self):
        """Show the exact code changes needed"""

        print("\n" + "=" * 60)
        print("REQUIRED CODE CHANGES")
        print("=" * 60)

        print("\nFile: src/postgres_mcp/server.py")
        print("Function: execute_sql (around line 390)")

        print("\nCURRENT VULNERABLE CODE:")
        print("""
async def execute_sql(sql: str = Field(...)) -> ResponseType:
    \"\"\"Executes a SQL query against the database.\"\"\"
    try:
        sql_driver = await get_sql_driver()
        rows = await sql_driver.execute_query(sql)  # VULNERABLE!
        if rows is None:
            return format_text_response("No results")
        return format_text_response(list([r.cells for r in rows]))
    except Exception as e:
        logger.error(f"Error executing query: {e}")
        return format_error_response(str(e))
""")

        print("\nFIXED SECURE CODE:")
        print("""
async def execute_sql(
    query: str = Field(description="SQL query template with %s placeholders"),
    params: Optional[List[Any]] = Field(description="Parameters for the query", default=None)
) -> ResponseType:
    \"\"\"Executes a SQL query against the database with parameter binding.\"\"\"
    try:
        sql_driver = await get_sql_driver()
        rows = await sql_driver.execute_query(query, params=params)  # SECURE!
        if rows is None:
            return format_text_response("No results")
        return format_text_response(list([r.cells for r in rows]))
    except Exception as e:
        logger.error(f"Error executing query: {e}")
        return format_error_response(str(e))
""")

        print("\nSUMMARY OF CHANGES:")
        print("   1. Add 'params' parameter to function signature")
        print("   2. Pass params to execute_query() method")
        print("   3. Update function description to mention parameter binding")
        print("   4. Users must use %s placeholders in their queries")


async def main():
    """Run the vulnerability demonstration"""

    print("SQL INJECTION VULNERABILITY DEMONSTRATION")
    print("Postgres MCP Server - Same issue as Anthropic SQLite MCP")
    print("=" * 60)

    # Database connection
    connection_url = os.environ.get("DATABASE_URL", "postgresql://postgres:postgres@host.docker.internal:5432/postgres")

    # Mask password in display
    display_url = connection_url
    if "@" in display_url and ":" in display_url:
        parts = display_url.split("@")
        if len(parts) == 2:
            user_pass = parts[0].split("://")[1]
            if ":" in user_pass:
                user, _ = user_pass.split(":", 1)
                display_url = display_url.replace(user_pass, f"{user}:****")

    print(f"Database: {display_url}")

    if not os.environ.get("SKIP_CONFIRMATION"):
        response = input("\nRun vulnerability demonstration? (y/N): ")
        if response.lower() != "y":
            print("Demonstration cancelled.")
            return

    try:
        demo = VulnerabilityDemo(connection_url)

        await demo.setup_demo_environment()
        await demo.demonstrate_vulnerable_function()
        await demo.demonstrate_restricted_mode_protection()
        await demo.demonstrate_proper_fix()
        demo.show_code_fix()

        print("\n" + "=" * 60)
        print("CONCLUSION")
        print("=" * 60)
        print("The Postgres MCP server has the SAME SQL injection vulnerability")
        print("   as the original Anthropic SQLite MCP server!")
        print()
        print("The fix is simple: implement parameter binding in execute_sql")
        print("Restricted mode (SafeSqlDriver) already provides protection")
        print("Consider making restricted mode the default for production")
        print()
        print("Next steps:")
        print("   1. Apply the parameter binding fix")
        print("   2. Run comprehensive security tests")
        print("   3. Contribute the fix back to the original project")

    except Exception as e:
        print(f"\nUnexpected error during demonstration: {e}")
        print("This indicates a test setup issue, not a security test failure")
        return 1

    return 0


if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)
